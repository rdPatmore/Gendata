import numpy as np
import matplotlib.pyplot as plt
import struct
from Gendata import gendata as gen
from BLS.Data.Cat.scripts import load_cat
import xarray as xr
import BLS.Calc.coordinate_transforms as trans


##====================================================##
##            >>--regridMaster.py--<<
## 
## Ryan Patmore 17/07/15
## Outputs all required for regridding in MITgcm
##====================================================##

case_name = 'ISOBLR2_001'

# Set grid
zres  = 1.0 
hres  = 1.0
Lx    = 100 # length in metres
Ly    = 100 
Lz    = 100
ydim  = int(Ly / hres) # number of y cells
xdim  = int(Lx / hres) # number of x cells

# Set boundary shift
topo_shift_ratio = 1. / 100.
topo_shift = int(topo_shift_ratio * Ly / zres)
 
# set number of z grid cells
zdim = int((Lz / zres) + 2 + topo_shift)
print (' ')
print (' ')
print (' ')
print (' ')
print (' ')
print ('ZDIM', zdim)
print (' ')
print (' ')
print (' ')
print (' ')
print (' ')

depMax       = 9
wall_west    = 0
wall_east    = xdim
wall_south   = 0
wall_north   = 0 
 
iceDep = 1

# EOS
rhoConst = 1030
tAlpha = 3.9e-5
sBeta = 7.41e-4

g = 9.81

# Temperature
t_low  = 1.0000001 
t_high = 1

# Salinity
s_low  = 34.0 
s_high = 34.5

# Pressure
# suposed realistic values
#p_low  = 1000e2
p_low  = 1000e2
p_high = 4000e2
etaGrad = 0.00001

# Velocity
v_low = 1
v_high = 2

cd = 0.0012
       
wind       = 0
temp       = 0
salt       = 0
pressure   = 0
shice      = 0
rbcs       = 0



ini_params = { 'xdim'  : xdim,
               'ydim'  : ydim,
               'zdim'  : zdim,
               'g'     : g,
               'sBeta' : sBeta,
               'tAlpha': tAlpha,
               'rhoConst': rhoConst,
               'depMax': depMax,
               'iceDep': iceDep,
               's_low' : s_low,
               's_high' : s_high,
               't_low' : t_low,
               't_high': t_high }

state = gen.State(ini_params)

def interp_hourly_time(ds):
    import pandas as pd
    date = pd.to_datetime('1971-01-01 00:00:00')
    time_range = date + pd.to_timedelta(np.arange(31), 'H')
    ds = ds.interp({'TIME': time_range}, kwargs={'fill_value': np.nan})
    return ds

def get_cat_profile(time, quantity):
    cat = load_cat()
    cat = interp_hourly_time(cat)
    cat_prof = cat.isel(TIME=-1)
    cat_quantity = cat_prof[quantity]
    return cat_quantity

def ini_cat(time):
    ''' make files for cat initialiation '''

    # load cat profiles
    T = get_cat_profile(time, 'THETA_spatial_mean')
    S = get_cat_profile(time, 'SALT_spatial_mean')
    U = get_cat_profile(time, 'UVEL_spatial_mean')
    V = get_cat_profile(time, 'VVEL_spatial_mean')


    # set masked values
    ambiant_T = -0.12195
    ambiant_S = 34.5
    freeze_T = ambiant_T - 2
    freeze_S = 34.5
    

    cat = xr.merge([T,S,U,V])

    # interp to 1 m grid
    cat = cat.interp({'new_Z': np.linspace(-101.5, 1.5, zdim)},
                 kwargs={'fill_value': np.nan})
    array_shape = (state.ydim, state.xdim)
    dummy = xr.DataArray(np.full(array_shape, freeze_T), 
                         dims=['Y', 'X'],
                         coords={'X':np.arange(xdim),
                                 'Y':np.arange(ydim)})
    cat_3d = cat.broadcast_like(dummy, exclude='new_Z')
    cat_3d['X_dash'], cat_3d['Y_dash'], cat_3d['Z_dash'] = trans.rotate_coords(                                                           cat_3d.X, 
                                                          cat_3d.Y, 
                                                          cat_3d.new_Z,
                                                          cat_3d.X.mean(),
                                                          cat_3d.Y.mean(),
                                                          cat_3d.new_Z.mean(),
                                                          np.arctan(-1/100))
    # shift coords to leave ice gap
    #cat_3d['Z_dash'] = cat_3d['Z_dash'] - 2

    cat_3d = cat_3d.assign_coords(X_dash=cat_3d['X_dash'], 
                                  Z_dash=cat_3d['Z_dash'])
    cat_3d = cat_3d.isel(Y=0)

    from scipy.interpolate import griddata
    def interpolate(cat_3d, da):
        X, Z = np.meshgrid(cat_3d.X, cat_3d.new_Z)
        grid = griddata((cat_3d.X_dash.values.ravel(), 
                         cat_3d.Z_dash.values.ravel()),
                         cat_3d[da].values.ravel(),
                         (X, Z), method='linear')
        return grid

    def make_ini_file(field, fname, fill_value, rand=False):
        ini_f = interpolate(cat_3d, field)
        ini_f = np.broadcast_to(ini_f.T, (state.ydim,state.xdim,state.zdim))
        ini_f = np.moveaxis(ini_f, 0, 1).T
        
        ini_f.setflags(write=1)

        # fill gaps generated by rotation
        ini_f[:,:,0] = ini_f[:,:,1]
        ini_f[:,:,-1] = ini_f[:,:,-2]

        # flip vertical axis
        ini_f = ini_f[::-1]

        # -- random kick -- #
        if rand:
            kick = 2e-4
            ini_f = ini_f + (kick * (np.random.rand(*state.shape) - 0.5))

        # fill nans
        ini_f[np.isnan(ini_f)] = fill_value

        # save
        name  = case_name + '_' + fname + '.bin'
        state.writeBin(ini_f, name)
        
        return ini_f, name

    t, name = make_ini_file('THETA_spatial_mean', 'ini_theta', ambiant_T, rand=False)
    make_ini_file('SALT_spatial_mean', 'ini_salt', ambiant_S, rand=False)
    make_ini_file('UVEL_spatial_mean', 'ini_uvel', 0, rand=True)
    make_ini_file('VVEL_spatial_mean', 'ini_vvel', 0, rand=True)

    y = state.readBin(name,int(xdim),int(ydim),int(zdim))
    fig = plt.figure(3)
    p = plt.pcolormesh(cat_3d.X, cat_3d.new_Z, y[:,0,:])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('temp')
    plt.show()

#ini_cat(200)
    

# MITgcm binary file is saved in (x,y) format

def make_ini_temp():
    name = case_name + '_ini_temp.bin'
    #t0 = state.add_heat_blob(state.gridx, state.gridz, 90, 170, 15)
    #t0 = state.ini_field_hill(state.xdim, state.gridx, 0.1)
    #t = state.ini_field_linear_grad(state.zdim, state.gridz, t_low, t_high)
    
    hFacC = state.readBin('ISOBL_024_hFacC.bin',int(xdim),int(ydim), int(zdim))
    t = np.full(state.gridx.shape, -0.1451) # uniform pforce
    ice_end = np.argmax(np.where(hFacC < 1 , t, 0), axis=0)
    bathy_start = np.argmax(np.where(hFacC[::-1] < 1 , t, 0), axis=0)
    for i in range(t.shape[2]):
        for j in range(t.shape[1]):
            for k in range(ice_end[j,i], 122-bathy_start[j,i]):
                t[k,j,i] = -0.1451 + ( (2/109) * k )
            for k in range(122-bathy_start[j,i], 122):
                t[k,j,i] = 1.8549
    plt.figure()
    p = plt.pcolor(t[:,0,:])
    plt.colorbar(p)
    plt.show()
    print ('tshape', t[4,0,0])
    #t[:2,:,:] = t[0,0,0]
    print ('tshape', t[4,0,0])
    #t = t0 + t1
    print (state.shape)
    #t = np.full(state.shape, 1)
    
    #t[2,0,-3] = 2
    #t[50,0,-10] = 2
    #t[1,0,-3] = 2
    print ('state.shape', state.shape)
    print ('gridz.shape', state.gridx.shape)
    state.writeBin(t,name)
    y = state.readBin(name,int(xdim),int(ydim),int(zdim))
    fig = plt.figure(3)
    p = plt.pcolormesh(y[:,0,:])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('temp')


def make_ini_salt():
    name = case_name + '_ini_salt.bin'
    s0 = state.ini_field_hill(state.xdim, state.gridx, 0.05)
    s1 = state.ini_field_linear_grad(state.zdim, state.gridz, t_low, t_high)
    s = s0 + s1
    s = np.full(state.gridx.shape, 34.5714) # uniform pforce
    state.writeBin(s,name)
    y = state.readBin(name,int(xdim),int(ydim),int(zdim))
    fig = plt.figure(4)
    p = plt.pcolormesh(y[:,0,:])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('temp')

def make_pressure_force():
    name = case_name + '_pForceX.bin'
    #pload = state.ini_p_force(state.xdim, state.gridx, p_low, p_high)
    #pload = pload * state.gridz[:,:,::-1] / state.gridz.max()
    pload = np.full(state.gridx.shape, rhoConst * g * etaGrad) # uniform pforce
    #pload = np.full(state.gridx.shape, g * etaGrad) # uniform pforce
    #pload = np.full(state.shape, 0)
    
    #pload[2,0,-2] = 0.001
    state.writeBin(pload,name)
    y = state.readBin(name,int(xdim),int(ydim),int(zdim))
    fig = plt.figure(4)
    print ('pressure shape', y.shape)
    p = plt.pcolormesh(y[:,0,:])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('pressure')

def make_ini_shice_topo(): 
    ShiceTopo  = case_name + '_ini_shice_topo.bin'
    shice_topo = - np.full((state.ydim, state.xdim), iceDep)
    #mesh = np.mgrid[0:int(ydim),0:int(xdim)][1]
    #h0 = -50
    #h1 = -2.5
    #dhdx = (h1 - h0) / (xdim - 1)
    #shice_topo = -50 + (mesh * dhdx)
    #b[:,:2]  = -50 
    #b[:,-2:] = -7.5

    # ---------------------------------------- #
    # shelf-ice topo Stepping for when hFacMin==1
    #step = 4
    #intervals = np.arange(int(step/2),100,step)
    #shice_topo[:,:intervals[0]] = - 1 - len(intervals) 
    #for i, pos in enumerate(intervals[::-1]):
    #    print ('pos', pos)
    #    print ('pos', pos-step)
    #    shice_topo[:,pos-step:pos] = -2 - i
    #shice_topo[:,intervals[-1]:] = - 1  
    # ---------------------------------------- #

    # ---------------------------------------- #
    # shelf-ice topo Stepping for when hFacMin!=1
    ice_min = -zres * (1 + topo_shift)
    ice_max = -zres *  1
    print ('ICE_MIN', ice_min)
    print ('ICE_MAX', ice_max)
    depths = np.linspace(ice_min,ice_max,xdim-2)
    shice_topo = shice_topo.astype('float64')
    for i, depth in enumerate(depths):
        shice_topo[:,i+1] = depth 
    shice_topo[:,0] = ice_min
    shice_topo[:,-1] = ice_max
    # ---------------------------------------- #

    #pos = int(xdim/2)
    #shice_topo[:,:pos] = -2 
    #shice_topo[:,pos:pos + 1] = -2 
    #shice_topo[:,:25] = -3 
    #shice_topo[:,25:75] = -2 
    state.writeBin(shice_topo, ShiceTopo)
    y = state.readBin(ShiceTopo,int(xdim),int(ydim))
    fig = plt.figure(5)
    p = plt.plot(y[0])
    plt.axis('equal')
    ##plt.colorbar(p)
    plt.title('ini_shice')

def make_ini_shice_rho():
    ShiceTopo  = case_name + '_ini_shice_p.bin'
    shice_topo =  np.full((state.ydim, state.xdim), 0)
    state.writeBin(shice_topo, ShiceTopo)
    y = state.readBin(ShiceTopo,int(xdim),int(ydim))
    fig = plt.figure(7)
    p = plt.plot(y[0])
    plt.axis('equal')
    plt.title('ini_shice_p')


if shice:
    # Check for initial state files
    if temp == 0:
        t = np.full(state.gridx.shape, -1.9)
    if salt == 0:
        s = np.full(state.gridx.shape, 34.4)

    # Set file names
    ShicePFile = case_name + '_ini_shice_p.bin'
    ShiceTopo  = case_name + '_ini_shice_topo.bin'
    
    # Make setup files
    #iceProfile = np.zeros((ydim,xdim))
    #iceProfile[0,:] = -1
    #iceProfile[0,:2] = -2
    mesh = np.mgrid[0:int(ydim),0:int(xdim)][1]
    h0 = -50
    h1 = -1
    dhdx = (h1 - h0) / xdim
    iceProfile = h0 + (mesh * dhdx)
    hFacC = state.readBin('../SHELF_hFacC.data', x=int(xdim), y=int(ydim),
                                                     z=int(zdim))
    #hFacC = np.ones((zdim,ydim,xdim))

    # Create MITgcm input files
    shice_topo, shice_p = state.ini_shice(iceProfile, t, s, hFacC)
    state.writeBin(shice_p, ShicePFile)
    state.writeBin(shice_topo, ShiceTopo)

    # Plot binary
    y = state.readBin(ShicePFile,int(xdim),int(ydim))
    fig = plt.figure(5)
    p = plt.pcolormesh(y)
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('shice')


def make_ini_vels(state):
    uName = case_name + '_ini_uvel.bin'
    vName = case_name + '_ini_vvel.bin'
    wName = case_name + '_ini_wvel.bin'
    #vels = state.add_heat_blob(state.gridx, state.gridz, 90, 100, 15)
    #vels = state.ini_field_linear_grad(state.zdim, state.gridz, v_low, v_high)

    # -- random kick -- #
    kick = 1e-3
    uVels = kick * (np.random.rand(*state.shape) - 0.5) * 2
    vVels = kick * (np.random.rand(*state.shape) - 0.5) * 2
    #wVels = kick * (np.random.rand(*state.shape) - 0.5)

    expon = 1
    if expon:
        mesh = (np.mgrid[0:int(zdim),0:int(ydim),0:int(xdim)][0] /
                int(zdim)) * np.pi
        exp = np.sin(mesh) * np.exp(mesh)[::-1]
        exp = exp / exp.max()
    else:
        exp = 1

    uKick = uVels * exp 
    vKick = vVels * exp 

    #wKick = wVels * exp 
    # -- random kick -- #


    #vels = np.full(state.shape, 0.0000001)
    
    #vels[2,0,-3] = 1
    state.writeBin(uKick,uName)
    state.writeBin(vKick,vName)
    #state.writeBin(wKick,wName)
    plot_2d(state, uName, xdim, ydim, zdim, title='vels',fnum=1)

def make_bathy(xdim, ydim, ini_params, hFacMin=None):
    name = case_name + '_bathy.bin'
    bathy = gen.Bathymetry(ini_params)
    b = bathy.get_bathy()#[::-1]
    mesh = np.mgrid[0:int(ydim),0:int(xdim)][1] 
     
    if hFacMin == 1: 
        # Bathy Stepping for when hFacMin=1
        step = 4
        intervals = np.arange(int(step/2),100,step)
        b[:,intervals[0]:] = -99  
        for i, pos in enumerate(intervals):
            b[:,pos:pos+step] = -98 + i
        b[:,intervals[-1]:] = -99 + len(intervals) 

    else:
        # Bathy Stepping for when hFacMin!=1
        #step = 5
        bathy_min = -(zdim   -1)*zres
        bathy_max = -(zdim - (1 + topo_shift))*zres
        print ('bathy min', bathy_min)
        print ('bathy max', bathy_max)
        depths = np.linspace(bathy_min,bathy_max,xdim-2)
        for i, pos in enumerate(depths):
            b[:,i+1] = depths[i] 
        b[:,0] = bathy_min 
        b[:,-1] = bathy_max
        # ---------------------------------------- #

    bathy.writeBin(b,name)
    plot_1d(bathy, name, xdim, ydim, title='bathy', fnum=0)
    return b

def plot_1d(data, data_dir, xdim, ydim, title='',fnum=0):
    y = data.readBin(data_dir,int(xdim),int(ydim))
    fig = plt.figure(fnum)
    p = plt.plot(y[0])
    plt.axis('equal')
    plt.title(title)

def plot_2d(state, data_dir, xdim, ydim, zdim, title='', fnum=0):
    y = state.readBin(data_dir,int(xdim), int(ydim), int(zdim))
    fig = plt.figure(fnum)
    p = plt.pcolormesh(y[:,:,0])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title(title)
    
 

def make_wind():
    wind_name = case_name + '_wind.bin'
    #print wind_name
    w = Wind()
    #w.ydim = 144
    #w.wind()
    w.shrunk_wind()
    wind = w.get_wind() #wind = np.hstack( (wind,np.zeros((288,144))) )
    #wind = np.hstack( (wind,-wind) )
    #wind = wind - wind.min()
    
    #wind = w.readBin(wind_name, xdim, ydim)
    #w.plot_single(wind)
    #wind[:,144:] = np.zeros((288,144))
    #w.plot_num = 1

    w.writeBin(wind, wind_name)
    wind = w.readBin(wind_name, int(ydim), int(xdim))
    w.case = '001'
    plt.figure(101)
    p = plt.pcolormesh(wind)
    plt.colorbar(p)
    #plt.figure(100)
    #plt.plot(wind[0,:])
    plt.show()

def make_rbcs(b, temp=-0.12195, salt=34.5, modelSalt=True):
    mask_name = case_name + '_rbcs_mask.bin'
    t_name = case_name + '_rbcs_temp.bin'
    if modelSalt:
         s_name = case_name + '_rbcs_salt.bin'
    mesh = np.mgrid[0:int(zdim),0:int(ydim),0:int(xdim)][0] 
    mesh = (mesh + 1) * zres
    
    rbcs_mask = np.where(mesh >= -b, 1.0, 0.0) 
    mask_args = np.argmax(rbcs_mask, axis=0)
    d = np.arange(xdim)
   
    time_scale = np.logspace(-2,0,int(32/zres),endpoint=True)[::-1]
    print ('TIME', time_scale)
    for i, frac in enumerate(time_scale):
        rbcs_mask[mask_args - i,:, d] = frac
    rbcs_t = np.full_like(rbcs_mask, temp)
    if modelSalt:
        rbcs_s = np.full_like(rbcs_mask, 34.5)
        state.writeBin(rbcs_s, s_name)

    state.writeBin(rbcs_mask, mask_name)
    state.writeBin(rbcs_t, t_name)
    y = state.readBin(mask_name, int(xdim),int(ydim),int(zdim))
    fig = plt.figure(1)
    p = plt.pcolormesh(y[:,0,:])
    plt.axis('equal')
    plt.colorbar(p)
    plt.title('mask')

bathy = make_bathy(xdim, ydim, ini_params)
make_ini_shice_topo()
make_ini_shice_rho()
make_ini_vels(state)
make_rbcs(bathy, temp=2, modelSalt=False)
#ini_cat(200)
#plt.show()
